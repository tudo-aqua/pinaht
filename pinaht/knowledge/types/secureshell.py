###############################################################################
# Generated By: generate.py
# User: -
# Date: -
###############################################################################

from pinaht.knowledge.types.knowledge import Knowledge  # noqa F401


from pinaht.knowledge.types.shell import Shell

from pinaht.knowledge.types.privilege import Privilege

from pinaht.knowledge.types.user import User


from pinaht.knowledge.types.shell import ShellTimeoutError

import paramiko

import random

import string

import socket

import re


class SecureShell(Shell):
    """
    Uses paramiko package to create a shell and execute commands over SSH.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor of the class SecureShell.
        """

        super().__init__()
        self.init_secureshell(*args)

        self.privilege = []

        self.shelluser = []

        self.type = "BRANCH"
        self.lookup = {"privilege": self.privilege, "shelluser": self.shelluser}

        for key, item in kwargs.items():
            if isinstance(item, list):
                for element in item:
                    self.add_child(key, element)
            else:
                self.add_child(key, item)

    def __str__(self):
        return self.__class__.__name__

    def fuzzy_eq(self, other) -> float:
        # TODO
        if id(self) == id(other):
            return 1.0
        if not type(self) == type(other):
            return 0.0
        return 0.5

    def add_child(self, key, child):
        if key not in self.lookup:
            raise ValueError(
                f"Type 'SecureShell' has no child/attribute with name {key}. "
                "Check types.yaml or the generated PDF for correct identifiers."
            )

        if key == "privilege" and isinstance(child, Privilege):
            self.privilege.append(child)
            child.parent = self

        elif key == "shelluser" and isinstance(child, User):
            self.shelluser.append(child)
            child.parent = self

        else:
            raise TypeError(f"Child for attribute {key} is not of the right type")

    def init_secureshell(self, *args):  # noqa F811
        pass

    ### USER DEFINED METHODS ### # noqa: E266

    # Random string that acts as an indicator for a finished shell output
    SEPARATOR = "".join(random.choice(string.ascii_lowercase) for i in range(10))

    def init_secureshell(self, *args):  # noqa F811
        """
        Creates a wrapper for a Python socket shells.

        :param args[0]: User to log into.
        :param args[1]: Password to use.
        :param args[2]: IP the SSH-Service runs on.
        :param args[3]: Port the SSH-Service runs on.

        """

        # Set up Client and Keys.
        self._shell = paramiko.SSHClient()
        self._shell.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self._shell.load_system_host_keys(filename=None)

        try:
            self._shell.connect(args[2], username=args[0], password=args[1], port=args[3])
            # AuthenticationException – if authentication failed
            # SSHException – if there was any other error connecting or establishing an SSH session
            # socket.error – if a socket error occurred while connecting
        except paramiko.AuthenticationException:
            self._logger.debug("Authentication Error. Probably wrong password or username.")
            raise paramiko.AuthenticationException
        except socket.error:
            self._logger.debug("Error with socket, cant connect to target.")
            raise socket.error
        except paramiko.SSHException:
            self._logger.debug("Cannot open SSH Channel, due to SSHException from paramiko. (1)")
            raise paramiko.SSHException

        try:
            self.channel = self._shell.invoke_shell()
            # Raises: SSHException – if the request was rejected or the channel was closed
        except paramiko.SSHException:
            self._logger.debug("Cannot open SSH Channel, due to SSHException from paramiko. (2)")
            raise paramiko.SSHException

        # create stdin/stdout buffer
        self.stdin = self.channel.makefile("wb")
        self.stdout = self.channel.makefile("r")

        # Set the shell-width to a large ammount, to prevent wonky error with \r in output..
        self.shellwidth = 10000
        shout = self.execute("stty cols " + str(self.shellwidth) + "; tput cols")
        if shout[0] == str(self.shellwidth) + "\n":
            self._logger.info("Set terminal width of SecureShell to " + str(self.shellwidth) + ".")
        else:
            self._logger.error("Cannot set terminal width of SecureShell to " + str(self.shellwidth) + ".")
        # Set prompt to single character, to make the check for too long commands easier.
        self.execute("PS1='\\$ ' \n")
        self._logger.info("Set prompt of SecureShell to $ .")

    def execute(self, command, timeout=10, new_shell=False):
        """
        Executes a command in the shell and returns its output. When called more then one time, the previous command
        affects the following ones.

        :param command: Command to execute. (String)
        :param timeout: Number of seconds after which to raise a ShellTimeoutError exception. (int)
        :param new_shell: Declares, if a command will result in a new Shell. False by default. (boolean)

        :return: The shells output. (String)
        """

        self.channel.settimeout(timeout)

        shout = []
        exit_status = 0

        command = command.strip("\n")
        echo_sep = "echo {}".format(self.SEPARATOR)

        # Seperator between command and echo_sep.
        # '&&' produces ShellTimeoutError, because the echo_sep command is not executed
        conc = " ; "

        # Check width of command, that will be executed
        if len(command + conc + echo_sep + "\n") + 25 >= self.shellwidth:  # +25 = margin of error
            self._logger.warning(
                "The command to be executed with SecureShell is longer then the current terminal "
                "width of " + str(self.shellwidth) + ". This may cause false handling of the "
                "shells's answer, because of \\r added to the answer."
            )

        if new_shell:  # flush a second echo to recognize correct ending.
            self.stdin.write(command + conc + echo_sep + "\n")
            self.stdin.flush()
            self.stdin.write(echo_sep + " $? \n")
            self.stdin.flush()

        else:
            self.stdin.write(command + conc + echo_sep + " $? \n")
            self.stdin.flush()

        try:
            for line in self.stdout:
                if (command + conc + echo_sep) in str(line):  # step over the flushed command
                    shout = []

                elif echo_sep in str(line):
                    pass

                elif self.SEPARATOR in str(line):  # find separator to validate execution
                    exit_status = int(str(line).rsplit(maxsplit=1)[1])
                    break

                else:  # get rid of 'coloring and formatting' special characters and append to known output.
                    shout.append(
                        re.compile(r"(\x9B|\x1B\[)[0-?]*[ -/]*[@-~]")
                        .sub("", line)
                        .replace("\b", "")
                        .replace("\r", "")
                    )

        except socket.timeout:
            raise ShellTimeoutError

        self._logger.debug("Command: " + command + " ~> exit status: " + str(exit_status))

        if new_shell:
            self.stdin.write("PS1='\\$ '" + "\n")
            self.stdin.flush()

        return shout
