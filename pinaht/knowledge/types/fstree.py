###############################################################################
# Generated By: generate.py
# User: -
# Date: -
###############################################################################

from pinaht.knowledge.types.knowledge import Knowledge  # noqa F401


import string


class FsTree(Knowledge):
    """
    Tree structure mirroring the target's filesystem
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor of the class FsTree.
        """

        super().__init__()
        self.init_fstree(*args)

        self.type = "ABSTRACT"
        self.lookup = {}

        for key, item in kwargs.items():
            if isinstance(item, list):
                for element in item:
                    self.add_child(key, element)
            else:
                self.add_child(key, item)

    def fuzzy_eq(self, other) -> float:
        # TODO
        if id(self) == id(other):
            return 1.0
        if not type(self) == type(other):
            return 0.0
        return 0.5

    def add_child(self, key, child):
        if key not in self.lookup:
            raise ValueError(
                f"Type 'FsTree' has no child/attribute with name {key}. "
                "Check types.yaml or the generated PDF for correct identifiers."
            )

        else:
            raise TypeError(f"Child for attribute {key} is not of the right type")

    def init_fstree(self, *args):  # noqa F811
        pass

    ### USER DEFINED METHODS ### # noqa: E266

    def init_fstree(self, *args):  # noqa F811
        self.filesystem = File("", "", "")

    def get_info(self, path):
        current_file = self.filesystem
        while True:
            if path == "/" or path == "":
                return current_file
            path = path.lstrip("/")
            if "/" not in path:
                if current_file.files[path]:
                    return current_file.files[path]
                else:
                    return False
            split = path.split("/", 1)
            if current_file.files[split[0]]:
                current_file = current_file.files[split[0]]
                path = split[1]
            else:
                return False

    def get_data(self, path):
        pass

    def insert(self, path, owner, group, access_rights):
        self.filesystem.insert(path, owner, group, access_rights)

    def get_all_files(self):
        return self.filesystem.get_file_paths("")

    def __str__(self):
        MAX_FILES = 4  # noqa N806
        all_files = self.get_all_files()
        files = all_files[:MAX_FILES]
        files_str = "\n".join(files)
        if len(all_files) > MAX_FILES:
            files_str += "\n..."
        return files_str


class File:
    def __init__(self, owner, group, access_rights):
        self.owner = owner
        self.group = group
        self.access_rights = access_rights
        self.files = {}

    def insert(self, file, owner, group, access_rights):
        # Only ASCII characters (and german) allowed...
        allowed = string.ascii_letters + string.digits + string.punctuation + "äöüßÄÖÜ"
        for char in file:
            if char not in allowed:
                return False
        if "/" in file:
            path = file.split("/", 1)
            if path[0] not in self.files:
                self.files.update({path[0]: File("", "", "")})
            return self.files[path[0]].insert(path[1], owner, group, access_rights)
        else:
            new_file = File(owner, group, access_rights)
            self.files.update({file: new_file})
            return True

    def get_file_paths(self, path):
        filepaths = []
        for file_name in self.files.keys():
            if self.files[file_name].files == {}:
                filepaths.append(path + "/" + file_name)
            else:
                filepaths.extend(self.files[file_name].get_file_paths(path + "/" + file_name))
        return filepaths
