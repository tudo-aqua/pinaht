###############################################################################
# Generated By: generate.py
# User: -
# Date: -
###############################################################################

from pinaht.knowledge.types.knowledge import Knowledge  # noqa F401


class Version(Knowledge):
    """
    Describes an Object of the Type Version.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor of the class Version.
        """

        super().__init__()
        self.init_version(*args)

        self.type = "LEAF_CUSTOM"
        self.lookup = {}

        for key, item in kwargs.items():
            if isinstance(item, list):
                for element in item:
                    self.add_child(key, element)
            else:
                self.add_child(key, item)

    def fuzzy_eq(self, other) -> float:
        # TODO
        if id(self) == id(other):
            return 1.0
        if not type(self) == type(other):
            return 0.0
        return 0.5

    def add_child(self, key, child):
        if key not in self.lookup:
            raise ValueError(
                f"Type 'Version' has no child/attribute with name {key}. "
                "Check types.yaml or the generated PDF for correct identifiers."
            )

        else:
            raise TypeError(f"Child for attribute {key} is not of the right type")

    def init_version(self, *args):  # noqa F811
        pass

    ### USER DEFINED METHODS ### # noqa: E266

    def init_version(self, *args):  # noqa F811
        if len(args) > 0:
            self.set_version(args[0])

    def set_version(self, version):
        self.version = version

    def __str__(self):
        """
        parses the version, that is represanted as a list of tuple to a string

        :return: a string
        """
        return ".".join(map(lambda x: "".join([str(y) for y in x]), self.version))

    def __eq__(self, other):
        return self.version == other.version

    def __lt__(self, other):
        return self.version < other.version

    def __gt__(self, other):
        return self.version > other.version

    def compare_to(self, other, depth=10 ** 10):
        """
        compares this version with a other version up to the given depth

        :param other: the other version
        :param depth: the depth up to which the version is compared
        :return:  0, if self.version == other.version
        -1, if self.version < other.version
        +1, if self.version > other.version
        """
        if not isinstance(other, Version):
            raise TypeError("other must be Version")
        if str(self.version[:depth]) == str(other.version[:depth]):
            return 0
        if str(self.version[:depth]) < str(other.version[:depth]):
            return -1
        if str(self.version[:depth]) > str(other.version[:depth]):
            return +1

    @staticmethod
    def parse_version(version):
        """
        parses the version input to a list, that separates the sup-versions.
        ' ' and '-' will be transformet to '.' and all letters will be transformet to lower case

        example: parse_version('10.4a4.12.2Aa.b') => [(10,), (4, 'a', 4), (12,), (2, 'aa'), ('b',)]

        :param version: the version, as list or string (with delimiter ".")
        :return: a list of tuple representing the sup-versions.
        """
        if type(version) == str:
            if version == "":
                return [()]
            version = list(version)
            version = "".join(map(lambda s: "." if s == "-" or s == " " else s, version))
            version = version.split(".")
        if type(version) != list:
            raise TypeError("version must be list or string")

        for i in range(len(version)):
            # handle empty string
            if version[i] == "":
                continue
            try:
                version[i] = (int(version[i]),)
            except ValueError:
                # sub_version is a mixture between numbers and letters
                sub_version = list(version[i])  # splits the version in single letters
                sub_version_list = [""]  # init new sub_version_list
                current = 0
                numbers = [str(k) for k in range(10)]  # contains the number 0-9 as strings
                is_number = sub_version[0] in numbers  # true if sub_version starts with a number

                for j in range(len(sub_version)):
                    # checks if version switches from int to string or vice versa
                    if (sub_version[j] in numbers and not is_number) or (not sub_version[j] in numbers and is_number):
                        if is_number:
                            sub_version_list[current] = int(sub_version_list[current])
                        else:
                            sub_version_list[current] = sub_version_list[current].lower()
                        current += 1
                        sub_version_list.append("")
                        is_number = not is_number

                    sub_version_list[current] += sub_version[j]

                if is_number:
                    sub_version_list[current] = int(sub_version_list[current])
                else:
                    sub_version_list[current] = sub_version_list[current].lower()

                version[i] = tuple(sub_version_list)

        return version
