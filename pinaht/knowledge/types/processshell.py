###############################################################################
# Generated By: generate.py
# User: -
# Date: -
###############################################################################

from pinaht.knowledge.types.knowledge import Knowledge  # noqa F401


from pinaht.knowledge.types.shell import Shell

from pinaht.knowledge.types.privilege import Privilege

from pinaht.knowledge.types.user import User


from pinaht.knowledge.types.shell import ShellTimeoutError

import pexpect

import random

import string


class ProcessShell(Shell):
    """
    Wraps shells in external processes.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor of the class ProcessShell.
        """

        super().__init__()
        self.init_processshell(*args)

        self.privilege = []

        self.shelluser = []

        self.type = "BRANCH"
        self.lookup = {"privilege": self.privilege, "shelluser": self.shelluser}

        for key, item in kwargs.items():
            if isinstance(item, list):
                for element in item:
                    self.add_child(key, element)
            else:
                self.add_child(key, item)

    def __str__(self):
        return self.__class__.__name__

    def fuzzy_eq(self, other) -> float:
        # TODO
        if id(self) == id(other):
            return 1.0
        if not type(self) == type(other):
            return 0.0
        return 0.5

    def add_child(self, key, child):
        if key not in self.lookup:
            raise ValueError(
                f"Type 'ProcessShell' has no child/attribute with name {key}. "
                "Check types.yaml or the generated PDF for correct identifiers."
            )

        if key == "privilege" and isinstance(child, Privilege):
            self.privilege.append(child)
            child.parent = self

        elif key == "shelluser" and isinstance(child, User):
            self.shelluser.append(child)
            child.parent = self

        else:
            raise TypeError(f"Child for attribute {key} is not of the right type")

    def init_processshell(self, *args):  # noqa F811
        pass

    ### USER DEFINED METHODS ### # noqa: E266

    # Random string that acts as an indicator for a finished shell output
    SEPARATOR = "".join(random.choice(string.ascii_lowercase) for i in range(10))

    def init_processshell(self, *args):  # noqa F811
        """
        Creates a wrapper for a shell in an external process.

        :param args[0]: a binary's path and arguments
        """
        try:
            self._shell = pexpect.spawn(args[0], echo=False)
            if not self.check():
                raise ShellSpawnError
        except (pexpect.exceptions.EOF, OSError):
            raise ShellSpawnError()

    def execute(self, command, timeout=10, new_shell=False):
        """
        Executes a command in the shell and returns its output.

        :param command: command to execute
        :param timeout: number of seconds after which to raise a ShellTimeoutError exception
        :return: shell output
        """
        self._shell.sendline(f"echo {self.SEPARATOR};{command};echo {self.SEPARATOR}")
        try:
            self._shell.expect(self.SEPARATOR, timeout=5)

            # discard echos if shell is echoing
            if self._shell.before.decode("utf-8").endswith("echo "):
                self._shell.expect(self.SEPARATOR, timeout=5)
                self._shell.expect(self.SEPARATOR, timeout=5)
        except (pexpect.TIMEOUT):
            self._logger.error("shell seems to be broken")
            raise ShellTimeoutError

        # wait for command execution to finish
        try:
            if new_shell:
                self._shell.sendline(f"echo {self.SEPARATOR}")
            self._shell.expect(self.SEPARATOR, timeout=timeout)
            output = self._shell.before.decode("utf-8")[2:-2]
            output_lines = output.splitlines()
            return output_lines
        except (pexpect.TIMEOUT):
            self._logger.error("command timeout expired")
            raise ShellTimeoutError


class ShellSpawnError(Exception):
    """
    Exception indicating that a shell has failed to spawn
    """

    pass
